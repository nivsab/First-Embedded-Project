/**
 ******************************************************************************
 * @file           : main.cpp
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "GpioDriver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// --- State Machine States ---
typedef enum {
    STATE_OFF = 0,
    STATE_ON,
    STATE_BLINK
} LedState_t;

// --- Hardware Definitions ---
// Board dependent. Usually LED on PA5, Button on PC13
#define LED_PIN       GPIO_PIN_NO_5
#define BUTTON_PIN    GPIO_PIN_NO_13

// --- Simple delay for software debounce ---
void softwareDelay(uint32_t count) {
    for(uint32_t i = 0; i < count; i++);
}

int main(void) {
    // 1. LED Initialization (Output)
    GPIO_PinConfig_t ledConf;
    ledConf.GPIO_PinNumber = LED_PIN;
    ledConf.GPIO_PinMode = GPIO_MODE_OUT;
    ledConf.GPIO_PinSpeed = GPIO_SPEED_LOW;
    ledConf.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    ledConf.GPIO_PinPuPdControl = GPIO_NO_PUPD;

    GpioDriver myLed(GPIOA, ledConf);
    myLed.init();

    // 2. Button Initialization (Input)
    // Note: Assuming Pull-Up configuration (Pressed = 0, Released = 1)
    GPIO_PinConfig_t btnConf;
    btnConf.GPIO_PinNumber = BUTTON_PIN;
    btnConf.GPIO_PinMode = GPIO_MODE_IN;
    btnConf.GPIO_PinSpeed = GPIO_SPEED_LOW;
    btnConf.GPIO_PinPuPdControl = GPIO_PIN_PU; // Pull-Up

    GpioDriver myBtn(GPIOC, btnConf); // Assuming button is on Port C
    myBtn.init();

    // 3. State Machine Variables
    LedState_t currentState = STATE_OFF;
    bool lastBtnState = true; // Default is 1 (Not pressed) due to Pull-Up

    // Blink variables (Non-blocking delay logic)
    uint32_t blinkCounter = 0;
    const uint32_t BLINK_INTERVAL = 50000; // Arbitrary value for timing

    while(1) {
        // --- Step A: Input Handling & Edge Detection ---
        bool currentBtnState = myBtn.read();

        // Check for Falling Edge (Transition from 1 to 0)
        if (lastBtnState == true && currentBtnState == false) {

            softwareDelay(20000); // Short debounce delay

            if (myBtn.read() == false) { // Verify button is still pressed

                // Cyclic state transition: OFF -> ON -> BLINK -> OFF
                if (currentState == STATE_OFF) {
                    currentState = STATE_ON;
                } else if (currentState == STATE_ON) {
                    currentState = STATE_BLINK;
                } else if (currentState == STATE_BLINK) {
                    currentState = STATE_OFF;
                }
            }
        }
        lastBtnState = currentBtnState; // Update for next iteration

        // --- Step B: State Machine Logic & Output ---
        switch (currentState) {
            case STATE_OFF:
                myLed.write(false); // Turn LED off
                blinkCounter = 0;   // Reset blink counter
                break;

            case STATE_ON:
                myLed.write(true);  // Turn LED on
                break;

            case STATE_BLINK:
                // --- Non-Blocking Blink Implementation ---
                blinkCounter++;
                if (blinkCounter >= BLINK_INTERVAL) {
                    myLed.toggle();   // Toggle LED state
                    blinkCounter = 0; // Reset counter
                }
                break;
        }
    }
}
